import test from 'node:test';
import assert from 'node:assert/strict';
import { spawnSync } from 'node:child_process';
import path from 'path';

// Helper to run a Node module in a clean process with env overrides
function runNodeModule(script, envOverrides = {}) {
  const nodeArgs = ['--input-type=module', '-e', script];
  const env = { ...process.env, ...envOverrides };
  const result = spawnSync(process.execPath, nodeArgs, { env, encoding: 'utf8' });
  if (result.error) throw result.error;
  return { stdout: result.stdout, stderr: result.stderr, status: result.status };
}

test('config parses comma-separated Gmail credentials (child process)', async () => {
  const script = `
    import('./backend/config.js').then(c=>{
      console.log(JSON.stringify({id:c.GMAIL_CLIENT_ID, secret:c.GMAIL_CLIENT_SECRET}));
    }).catch(e=>{ console.error(e); process.exit(2); });
  `;
  const env = {
    GMAIL_CLIENT_IDS: 'cid1,cid2',
    GMAIL_CLIENT_SECRETS: 'csec1,csec2',
    GMAIL_CLIENT_INDEX: '1'
  };
  const res = runNodeModule(script, env);
  assert.equal(res.status, 0, `child process failed: ${res.stderr}`);
  // stdout may contain other logs; find the first JSON object and parse it
  const s = res.stdout || '';
  const idx = s.indexOf('{');
  assert.ok(idx >= 0, `No JSON output found in child stdout: ${s}`);
  const out = JSON.parse(s.slice(idx).trim());
  assert.equal(out.id, 'cid2');
  assert.equal(out.secret, 'csec2');
});

test('performPerplexityRequest retries (unit)', async () => {
  // Monkeypatch axios before importing compose to ensure module uses the mock
  const axios = await import('axios');
  let calls = 0;
  axios.default.post = async (...args) => {
    calls += 1;
    if (calls < 3) {
      const err = new Error('simulated network');
      throw err;
    }
    return { status: 200, data: { text: 'ok' } };
  };

  const compose = await import('../routes/compose.js');
  process.env.PERPLEXITY_API_KEY = 'test';
  const resp = await compose.performPerplexityRequest('p', 'c', { retries: 3, timeout: 1000 });
  assert.equal(resp.data.text, 'ok');
  assert.ok(calls >= 3);
});

test('handleCompose falls back to Gemini when Perplexity returns auth error', async () => {
  const axios = await import('axios');
  // Mock axios.post to behave differently based on URL
  axios.default.post = async (url, body, opts) => {
    const u = String(url || '');
    if (u.includes('perplexity')) {
      const err = new Error('Unauthorized');
      err.response = { status: 401, data: { error: 'Invalid key' } };
      throw err;
    }
    if (u.includes('generativelanguage.googleapis.com')) {
      return { status: 200, data: { output_text: 'Generated by Gemini' } };
    }
    // default fallback
    return { status: 200, data: { results: [{ text: 'Generated email body' }] } };
  };

  // Ensure envs: Perplexity present (bad) and Gemini present (good)
  process.env.PERPLEXITY_API_KEY = 'bad';
  delete process.env.OPENAI_API_KEY;
  process.env.GOOGLE_GEMINI_API_KEY = 'gem-key';

  const { handleCompose } = await import('../routes/compose.js');

  const req = { body: { prompt: 'Write an email', context: 'context' } };
  const res = { statusCode: null, body: null, status(code) { this.statusCode = code; return this; }, json(obj) { this.body = obj; return this; } };

  await handleCompose(req, res);
  assert.equal(res.body.success, true);
  assert.equal(res.body.provider, 'gemini');
  assert.equal(res.body.text, 'Generated by Gemini');
});
